'use client';

import dynamic from 'next/dynamic';
import { Suspense, useState, useEffect, useCallback } from 'react';
import { CanvasPortalFallback } from './CanvasPortalFallback';
import { useCanvasComponentState } from './CanvasStateCoordinator';
import { useIntersectionObserver } from '@/hooks/useIntersectionObserver';

// Priority levels for progressive loading
export type LoadPriority = 'high' | 'medium' | 'low';

interface EnhancedLazy3DWrapperProps {
  children?: React.ReactNode;
  loadPriority?: LoadPriority;
  htmlFallback?: React.ReactNode; // HTML fallback rendered outside Canvas
  threeFallback?: React.ReactNode; // 3D fallback rendered inside Canvas (optional)
  loadingText?: string;
  className?: string;
  enabled?: boolean;
  componentId: string; // Required for state tracking
  componentName: string; // Human-readable name
  
  // Intersection observer options (for DOM-based loading)
  threshold?: number;
  rootMargin?: string;
  useIntersectionLoading?: boolean; // Whether to use intersection-based loading
  
  // Performance options
  delayMs?: number; // Additional delay before loading
  preload?: boolean; // Whether to preload when near viewport
  
  // Error handling
  onError?: (error: Error) => void;
  onLoad?: () => void;
}

/**
 * Enhanced wrapper that separates Canvas and DOM concerns
 * Provides both HTML fallbacks (via portal) and 3D fallbacks (inside Canvas)
 */
export default function EnhancedLazy3DWrapper({
  children,
  loadPriority = 'medium',
  htmlFallback,
  threeFallback,
  loadingText = 'Loading 3D elements...',
  className = '',
  enabled = true,
  componentId,
  componentName,
  threshold = 0.1,
  rootMargin = '100px',
  useIntersectionLoading = false,
  delayMs = 0,
  preload = false,
  onError,
  onLoad,
}: EnhancedLazy3DWrapperProps) {
  const [shouldLoad, setShouldLoad] = useState(!useIntersectionLoading);
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [loadProgress, setLoadProgress] = useState(0);

  // Register with state coordinator
  const { setState } = useCanvasComponentState(componentId, componentName, loadPriority);

  // Intersection observer for DOM-based loading
  const { isIntersecting, targetRef } = useIntersectionObserver({
    threshold,
    rootMargin,
    freezeOnceVisible: true,
  });

  // Update component state in coordinator
  useEffect(() => {
    if (hasError) {
      setState('error', 0, 'Failed to load 3D component');
    } else if (isLoaded) {
      setState('loaded', 100);
    } else if (shouldLoad) {
      setState('loading', loadProgress);
    } else {
      setState('loading', 0);
    }
  }, [hasError, isLoaded, shouldLoad, loadProgress, setState]);

  // Handle intersection-based loading
  useEffect(() => {
    if (!useIntersectionLoading) return;
    
    if (isIntersecting && !shouldLoad) {
      const priorityDelays = {
        high: 0,
        medium: 100,
        low: 300,
      };

      const totalDelay = priorityDelays[loadPriority] + delayMs;

      if (totalDelay > 0) {
        const timer = setTimeout(() => {
          setShouldLoad(true);
        }, totalDelay);
        
        return () => clearTimeout(timer);
      } else {
        setShouldLoad(true);
      }
    }
  }, [isIntersecting, shouldLoad, loadPriority, delayMs, useIntersectionLoading]);

  // Handle Canvas-based loading (immediate or delayed)
  useEffect(() => {
    if (useIntersectionLoading || !enabled) return;

    const priorityDelays = {
      high: 0,
      medium: 100,
      low: 300,
    };

    const totalDelay = priorityDelays[loadPriority] + delayMs;
    
    if (totalDelay > 0) {
      setShouldLoad(false);
      const timer = setTimeout(() => {
        setShouldLoad(true);
      }, totalDelay);
      
      return () => clearTimeout(timer);
    }
  }, [loadPriority, delayMs, enabled, useIntersectionLoading]);

  // Simulate loading progress (you can replace with actual loading progress)
  useEffect(() => {
    if (shouldLoad && !isLoaded && !hasError) {
      const progressInterval = setInterval(() => {
        setLoadProgress(prev => {
          const newProgress = prev + Math.random() * 20;
          if (newProgress >= 100) {
            setIsLoaded(true);
            onLoad?.();
            clearInterval(progressInterval);
            return 100;
          }
          return newProgress;
        });
      }, 100);

      return () => clearInterval(progressInterval);
    }
  }, [shouldLoad, isLoaded, hasError, onLoad]);

  const handleError = useCallback((error: Error) => {
    setHasError(true);
    onError?.(error);
  }, [onError]);

  if (!enabled) {
    return (
      <>
        {useIntersectionLoading && <div ref={targetRef} />}
        <group>
          {threeFallback || null}
        </group>
      </>
    );
  }

  const fallbackId = `${componentId}-fallback`;
  const showHtmlFallback = (!isLoaded || hasError) && htmlFallback;

  return (
    <>
      {useIntersectionLoading && <div ref={targetRef} />}
      
      {/* HTML Fallback via Portal */}
      {showHtmlFallback && (
        <CanvasPortalFallback
          id={fallbackId}
          fallbackComponent={htmlFallback}
          priority={loadPriority}
          visible={showHtmlFallback}
        />
      )}

      {/* Canvas Content */}
      <group className={className}>
        {shouldLoad && !hasError ? (
          <Suspense fallback={threeFallback || null}>
            <ErrorBoundaryCanvas onError={handleError}>
              {children}
            </ErrorBoundaryCanvas>
          </Suspense>
        ) : (
          threeFallback || null
        )}
      </group>
    </>
  );
}

/**
 * Error boundary that works inside Canvas context
 */
interface ErrorBoundaryCanvasProps {
  children: React.ReactNode;
  onError: (error: Error) => void;
}

class ErrorBoundaryCanvas extends React.Component<
  ErrorBoundaryCanvasProps,
  { hasError: boolean }
> {
  constructor(props: ErrorBoundaryCanvasProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): { hasError: boolean } {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Canvas Error Boundary caught error:', error, errorInfo);
    this.props.onError(error);
  }

  render() {
    if (this.state.hasError) {
      return null; // Return null for Canvas context
    }

    return this.props.children;
  }
}

// Higher-order component for creating enhanced lazy-loaded 3D components
export function withEnhancedLazy3D<P extends object>(
  Component: React.ComponentType<P>,
  options: Omit<EnhancedLazy3DWrapperProps, 'children' | 'componentId' | 'componentName'> & {
    componentId: string;
    componentName: string;
  }
) {
  const displayName = Component.displayName || Component.name || 'Component';
  
  const LazyComponent = (props: P) => (
    <EnhancedLazy3DWrapper {...options}>
      <Component {...props} />
    </EnhancedLazy3DWrapper>
  );

  LazyComponent.displayName = `withEnhancedLazy3D(${displayName})`;
  
  return LazyComponent;
}

// Utility function to create dynamically imported enhanced lazy 3D components
export function createEnhancedLazy3DComponent<P extends object>(
  importFn: () => Promise<{ default: React.ComponentType<P> }>,
  wrapperOptions: Omit<EnhancedLazy3DWrapperProps, 'children'> & {
    componentId: string;
    componentName: string;
  }
) {
  const DynamicComponent = dynamic(importFn, {
    ssr: false,
    loading: () => null, // Canvas-safe loading state
  });

  return withEnhancedLazy3D(DynamicComponent, wrapperOptions);
}